-- Create the messages table
CREATE TABLE IF NOT EXISTS public.messages (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  content text not null,
  college text not null,
  user_id uuid references auth.users not null,
  username text not null,
  avatar_color text not null,
  type text default 'text'::text,
  aura integer default 0,
  flags integer default 0,
  reactions jsonb default '{}'::jsonb,
  reports jsonb default '{}'::jsonb,
  reply_to_id bigint,
  hashtags text[] default '{}'::text[],
  group_name text default 'main',
  edited_at timestamp with time zone,
  is_edited boolean default false,
  thread_id bigint,
  me_too_count integer default 0,
  me_too_users text[] default '{}'::text[]
);

-- Add foreign key constraint separately to avoid errors if table doesn't exist yet
DO $$ 
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'messages_reply_to_id_fkey'
  ) THEN
    ALTER TABLE public.messages ADD CONSTRAINT messages_reply_to_id_fkey 
      FOREIGN KEY (reply_to_id) REFERENCES public.messages(id);
  END IF;
END $$;

-- Add group_name column if it doesn't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
    AND table_name = 'messages' 
    AND column_name = 'group_name'
  ) THEN
    ALTER TABLE public.messages ADD COLUMN group_name text default 'main';
  END IF;
END $$;

-- Add new feature columns if they don't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
    AND table_name = 'messages' 
    AND column_name = 'edited_at'
  ) THEN
    ALTER TABLE public.messages ADD COLUMN edited_at timestamp with time zone;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
    AND table_name = 'messages' 
    AND column_name = 'is_edited'
  ) THEN
    ALTER TABLE public.messages ADD COLUMN is_edited boolean default false;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
    AND table_name = 'messages' 
    AND column_name = 'thread_id'
  ) THEN
    ALTER TABLE public.messages ADD COLUMN thread_id bigint;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
    AND table_name = 'messages' 
    AND column_name = 'me_too_count'
  ) THEN
    ALTER TABLE public.messages ADD COLUMN me_too_count integer default 0;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
    AND table_name = 'messages' 
    AND column_name = 'me_too_users'
  ) THEN
    ALTER TABLE public.messages ADD COLUMN me_too_users text[] default '{}'::text[];
  END IF;
END $$;

-- Create index for hashtag queries
CREATE INDEX IF NOT EXISTS idx_messages_hashtags ON public.messages USING GIN(hashtags);
CREATE INDEX IF NOT EXISTS idx_messages_group_name ON public.messages(group_name);
CREATE INDEX IF NOT EXISTS idx_messages_college_group ON public.messages(college, group_name);
CREATE INDEX IF NOT EXISTS idx_messages_thread_id ON public.messages(thread_id) WHERE thread_id IS NOT NULL;

-- Create notifications table
CREATE TABLE IF NOT EXISTS public.notifications (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  type text not null,
  message_id bigint references public.messages(id) ON DELETE CASCADE,
  from_username text,
  content text,
  is_read boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON public.notifications(user_id);
CREATE INDEX IF NOT EXISTS idx_notifications_is_read ON public.notifications(user_id, is_read);

-- Track active hashtag groups (top 5 per college)
CREATE TABLE IF NOT EXISTS public.hashtag_groups (
  id bigint generated by default as identity primary key,
  college text not null,
  hashtag text not null,
  message_count integer default 0,
  last_message_at timestamp with time zone default timezone('utc'::text, now()) not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  created_by uuid references auth.users,
  is_active boolean default true
);

-- Add unique constraint separately
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'hashtag_groups_college_hashtag_key'
  ) THEN
    ALTER TABLE public.hashtag_groups ADD CONSTRAINT hashtag_groups_college_hashtag_key 
      UNIQUE(college, hashtag);
  END IF;
END $$;

-- Add is_active column if it doesn't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
    AND table_name = 'hashtag_groups' 
    AND column_name = 'is_active'
  ) THEN
    ALTER TABLE public.hashtag_groups ADD COLUMN is_active boolean default true;
  END IF;
END $$;

-- Add created_by column if it doesn't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
    AND table_name = 'hashtag_groups' 
    AND column_name = 'created_by'
  ) THEN
    ALTER TABLE public.hashtag_groups ADD COLUMN created_by uuid references auth.users;
  END IF;
END $$;

-- Create unique constraint: one active group per user
CREATE UNIQUE INDEX IF NOT EXISTS idx_one_group_per_user 
  ON public.hashtag_groups(created_by) 
  WHERE created_by IS NOT NULL AND is_active = true;

-- Create profiles table
CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid references auth.users primary key,
  email text,
  college text,
  username text,
  avatar_color text,
  gender text,
  branch text,
  year text,
  karma integer default 0,
  show_gender boolean default true,
  show_branch boolean default true,
  show_year boolean default true,
  show_karma boolean default true,
  role text default 'user',
  is_creator boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Add visibility columns if they don't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
    AND table_name = 'profiles' 
    AND column_name = 'show_gender'
  ) THEN
    ALTER TABLE public.profiles ADD COLUMN show_gender boolean default true;
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
    AND table_name = 'profiles' 
    AND column_name = 'show_branch'
  ) THEN
    ALTER TABLE public.profiles ADD COLUMN show_branch boolean default true;
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
    AND table_name = 'profiles' 
    AND column_name = 'show_year'
  ) THEN
    ALTER TABLE public.profiles ADD COLUMN show_year boolean default true;
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
    AND table_name = 'profiles' 
    AND column_name = 'show_karma'
  ) THEN
    ALTER TABLE public.profiles ADD COLUMN show_karma boolean default true;
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
    AND table_name = 'profiles' 
    AND column_name = 'role'
  ) THEN
    ALTER TABLE public.profiles ADD COLUMN role text default 'user';
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
    AND table_name = 'profiles' 
    AND column_name = 'is_creator'
  ) THEN
    ALTER TABLE public.profiles ADD COLUMN is_creator boolean default false;
  END IF;
END $$;

-- Add unique constraint for username separately
CREATE UNIQUE INDEX IF NOT EXISTS idx_profiles_username ON public.profiles(username);

-- Enable Row Level Security (RLS)
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.hashtag_groups ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist to avoid conflicts
DROP POLICY IF EXISTS "Public messages are viewable by everyone" ON public.messages;
DROP POLICY IF EXISTS "Users can insert their own messages" ON public.messages;
DROP POLICY IF EXISTS "Anyone can update messages (likes/flags)" ON public.messages;
DROP POLICY IF EXISTS "Anyone can delete messages" ON public.messages;

DROP POLICY IF EXISTS "Hashtag groups are viewable by everyone" ON public.hashtag_groups;
DROP POLICY IF EXISTS "Anyone can insert hashtag groups" ON public.hashtag_groups;
DROP POLICY IF EXISTS "Anyone can update hashtag groups" ON public.hashtag_groups;
DROP POLICY IF EXISTS "Anyone can delete hashtag groups" ON public.hashtag_groups;

DROP POLICY IF EXISTS "Profiles are viewable by everyone" ON public.profiles;
DROP POLICY IF EXISTS "Users can insert their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.profiles;

DROP POLICY IF EXISTS "Notifications are viewable by owner" ON public.notifications;
DROP POLICY IF EXISTS "Anyone can insert notifications" ON public.notifications;
DROP POLICY IF EXISTS "Users can update their own notifications" ON public.notifications;
DROP POLICY IF EXISTS "Users can delete their own notifications" ON public.notifications;

-- Messages Policies
CREATE POLICY "Public messages are viewable by everyone"
  ON public.messages FOR SELECT
  USING ( true );

CREATE POLICY "Users can insert their own messages"
  ON public.messages FOR INSERT
  WITH CHECK ( auth.uid() = user_id );

CREATE POLICY "Anyone can update messages (likes/flags)"
  ON public.messages FOR UPDATE
  USING ( true );

CREATE POLICY "Anyone can delete messages"
  ON public.messages FOR DELETE
  USING ( true );

-- Hashtag Groups Policies
CREATE POLICY "Hashtag groups are viewable by everyone"
  ON public.hashtag_groups FOR SELECT
  USING ( true );

CREATE POLICY "Anyone can insert hashtag groups"
  ON public.hashtag_groups FOR INSERT
  WITH CHECK ( true );

CREATE POLICY "Anyone can update hashtag groups"
  ON public.hashtag_groups FOR UPDATE
  USING ( true );

CREATE POLICY "Anyone can delete hashtag groups"
  ON public.hashtag_groups FOR DELETE
  USING ( true );

-- Profiles Policies
CREATE POLICY "Profiles are viewable by everyone"
  ON public.profiles FOR SELECT
  USING ( true );

CREATE POLICY "Users can insert their own profile"
  ON public.profiles FOR INSERT
  WITH CHECK ( auth.uid() = id );

CREATE POLICY "Users can update their own profile"
  ON public.profiles FOR UPDATE
  USING ( auth.uid() = id );

-- Notifications Policies
CREATE POLICY "Notifications are viewable by owner"
  ON public.notifications FOR SELECT
  USING ( auth.uid() = user_id );

CREATE POLICY "Anyone can insert notifications"
  ON public.notifications FOR INSERT
  WITH CHECK ( true );

CREATE POLICY "Users can update their own notifications"
  ON public.notifications FOR UPDATE
  USING ( auth.uid() = user_id );

CREATE POLICY "Users can delete their own notifications"
  ON public.notifications FOR DELETE
  USING ( auth.uid() = user_id );

-- Enable Realtime (will not error if already added)
DO $$
BEGIN
  ALTER PUBLICATION supabase_realtime ADD TABLE messages;
EXCEPTION
  WHEN duplicate_object THEN NULL;
END $$;

DO $$
BEGIN
  ALTER PUBLICATION supabase_realtime ADD TABLE hashtag_groups;
EXCEPTION
  WHEN duplicate_object THEN NULL;
END $$;

DO $$
BEGIN
  ALTER PUBLICATION supabase_realtime ADD TABLE profiles;
EXCEPTION
  WHEN duplicate_object THEN NULL;
END $$;

DO $$
BEGIN
  ALTER PUBLICATION supabase_realtime ADD TABLE notifications;
EXCEPTION
  WHEN duplicate_object THEN NULL;
END $$;
